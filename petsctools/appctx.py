import itertools
from functools import cached_property
from petsctools.exceptions import PetscToolsAppctxException


class AppContextKey(int):
    """A custom key type for AppContext."""
    pass


class AppContext:
    """
    Class for passing non-primitive types to PETSc python contexts.

    The PETSc.Options dictionary can only contain primitive types (str,
    int, float, bool) as values. The AppContext allows other types to be
    passed into PETSc solvers while still making use of the namespacing
    provided by options prefixing.

    A typical usage is shown below. In this example we have a python PC
    type `MyCustomPC` which requires additional data in the form of a
    `MyCustomData` instance.
    We can add the data to the AppContext with the `appctx.add` method,
    but we need to tell `MyCustomPC` how to retrieve that data. The
    `add` method returns a key which is a valid PETSc.Options entry,
    i.e. a primitive type instance. This key is passed via PETSc.Options
    with the 'custompc_somedata' prefix.

    The data can be retrieved in two ways.
    1) Giving the AppContext the (fully prefixed) option for the key,
       in which case the AppContext will internally fetch the key from
       the PETSc.Options and return the data.
    2) By manually fetching the AppContext key from the PETSc.Options,
       then retrieving the data from the `AppContext` using that key.

    .. code-block:: python3

        appctx = AppContext()
        some_data = MyCustomData(5)

        opts = OptionsManager(
            parameters={
                'pc_type': 'python',
                'pc_python_type': 'MyCustomPC',
                'custompc_somedata': appctx.add(some_data)},
            options_prefix='solver')

        with opts.inserted_options():
            # 1) Let AppContext fetch key.
            #    Also shows providing default data.
            default = MyCustomData(10)
            data = appctx.get('solver_custompc_somedata', default)

            # 2) Fetch key directly.
            key = PETSc.Options()['solver_custompc_somedata']
            data = appctx[key]
    """

    def __init__(self):
        self._count = itertools.count()
        self._data = {}

    def _keygen(self, key=None):
        """
        Generate a new internal key, optionally with a given value.

        This should not called directly by the user.

        Parameters
        ----------
        key : Optional[int]
            The value of the key.

        Returns
        -------
        new_key : AppContextKey
            A new internal key.
        """
        return AppContextKey(next(self._count) if key is None else key)

    def _option_to_key(self, option):
        """
        Return the internal key for the PETSc option `option`.
        If `option` is already an AppContextKey, `option` is returned.

        This should not called directly by the user.

        Parameters
        ----------
        option : Union[str, AppContextKey]
            The PETSc option.

        Returns
        -------
        key : AppContextKey
            An internal key corresponding to `option`.
        """
        if isinstance(option, int):
            return AppContextKey(option)
        key = self.options_object.getInt(option, self._missing_key)
        return self._keygen(key)

    @cached_property
    def _missing_key(self):
        """
        Key instance representing a missing AppContext entry.

        This should not called directly by the user.

        PETSc requires the default value for Options.getObj()
        to be the correct type, so we need a dummy key.
        """
        return self._keygen()

    def add(self, val):
        """
        Add a value to the application context and
        return the autogenerated key for that value.

        The autogenerated key should be used as the value for the
        corresponding entry in the solver_parameters dictionary.

        Parameters
        ----------
        val : Any
            The value to add to the AppContext.

        Returns
        -------
        key : AppContextKey
            The key to put into the PETSc Options dictionary.
        """
        key = self._keygen()
        self._data[key] = val
        return key

    def __getitem__(self, option):
        """
        Return the value with the key saved in `PETSc.Options()[option]`.

        Parameters
        ----------
        option : Union[str, AppContextKey]
            The PETSc option or key.

        Returns
        -------
        val : Any
            The value for the key `option`.

        Raises
        ------
        PetscToolsAppctxException
            If the AppContext does contain a value for `option`.
        """
        try:
            return self._data[self._option_to_key(option)]
        except KeyError:
            raise PetscToolsAppctxException(
                f"AppContext does not have an entry for {option}")

    def get(self, option, default=None):
        """
        Return the value with the key saved in PETSc.Options()[option],
        or if it does not exist return default.

        Parameters
        ----------
        option : Union[str, AppContextKey]
            The PETSc option or key.
        default : Any
            The value to return if `option` is not in the AppContext

        Returns
        -------
        val : Any
            The value for the key `option`, or `default`.
        """
        key = self._option_to_key(option)
        if key == self._missing_key:
            return default
        return self._data[key]

    @cached_property
    def options_object(self):
        """A PETSc.Options instance."""
        from petsc4py import PETSc
        return PETSc.Options()
